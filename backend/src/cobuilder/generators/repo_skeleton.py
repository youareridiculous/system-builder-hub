#!/usr/bin/env python3
"""
Repo Skeleton Generator for SBH Full Build Mode

Creates directories and boilerplate files as described in plan.
Ensures all packages have __init__.py (Python) or index.ts (TS).
Enforces SBH safety (atomic writes, no overwrite without anchor).
"""

import os
import logging
import traceback
from dataclasses import dataclass
from typing import List, Dict, Any, Optional
from pathlib import Path

from ..applier import apply_single_file, AnchoredPatch, apply_anchored_patch

logger = logging.getLogger(__name__)

@dataclass
class SkeletonConfig:
    """Configuration for repo skeleton generation"""
    project_root: str
    language: str = "python"  # python, typescript, javascript
    package_manager: str = "pip"  # pip, poetry, npm, yarn
    test_framework: str = "pytest"  # pytest, unittest, jest, mocha
    create_gitignore: bool = True
    create_readme: bool = True
    create_requirements: bool = True

@dataclass
class DirectorySpec:
    """Specification for a directory to create"""
    path: str
    description: str = ""
    files: List[str] = None
    subdirectories: List['DirectorySpec'] = None
    
    def __post_init__(self):
        if self.files is None:
            self.files = []
        if self.subdirectories is None:
            self.subdirectories = []

@dataclass
class FileSpec:
    """Specification for a file to create"""
    path: str
    content: str
    description: str = ""
    language: str = "python"

class RepoSkeletonGenerator:
    """Generates repo skeleton from plan specifications"""
    
    def __init__(self, config: SkeletonConfig):
        self.config = config
        self.created_paths: List[str] = []
        self.failed_paths: List[str] = []
    
    def _get_safe_workspace(self, build_id: str) -> Path:
        """Get safe per-build workspace directory"""
        # Resolve repo root (backend root)
        repo_root = Path(__file__).resolve().parents[2]  # backend root
        default_ws = repo_root / "workspace"
        ws = Path(os.environ.get("COB_WORKSPACE", default_ws))
        ws.mkdir(parents=True, exist_ok=True)
        target = ws / build_id
        target.mkdir(parents=True, exist_ok=True)
        return target
    
    def create_default_structure(self, build_id: str) -> Dict[str, Any]:
        """Create default directory structure for a build"""
        try:
            workspace = self._get_safe_workspace(build_id)
            
            # Create studio/intake_editor directory structure
            target_dir = workspace / "studio" / "intake_editor"
            target_dir.mkdir(parents=True, exist_ok=True)
            
            # Create __init__.py files for Python packages
            init_files = [
                workspace / "studio" / "__init__.py",
                target_dir / "__init__.py"
            ]
            
            for init_file in init_files:
                if not init_file.exists():
                    init_file.write_text("# Generated by SBH\n")
            
            return {
                "success": True,
                "file": str(target_dir),
                "path": str(target_dir),
                "lines_changed": 0,
                "sha256": "",
                "anchor_matched": False,
                "is_directory": True,
                "created_directories": [str(target_dir)],
                "created_files": [str(f) for f in init_files]
            }
            
        except Exception as e:
            logger.error(f"Error creating default structure: {e}")
            return {
                "success": False,
                "error": str(e),
                "file": "",
                "lines_changed": 0,
                "sha256": "",
                "anchor_matched": False
            }
    
    def generate_skeleton(self, directory_specs: List[DirectorySpec], file_specs: List[FileSpec]) -> Dict[str, Any]:
        """Generate complete repo skeleton from specifications"""
        results = {
            "created_directories": [],
            "created_files": [],
            "failed_operations": [],
            "total_operations": 0,
            "successful_operations": 0
        }
        
        try:
            # Create directories first
            for spec in directory_specs:
                result = self._create_directory_recursive(spec)
                results["created_directories"].extend(result["created"])
                results["failed_operations"].extend(result["failed"])
                results["total_operations"] += result["total"]
                results["successful_operations"] += result["successful"]
            
            # Create files
            for spec in file_specs:
                result = self._create_file(spec)
                if result["success"]:
                    results["created_files"].append(spec.path)
                    results["successful_operations"] += 1
                else:
                    results["failed_operations"].append({
                        "path": spec.path,
                        "error": result["error"]
                    })
                results["total_operations"] += 1
            
            # Create standard files if requested
            if self.config.create_gitignore:
                self._create_gitignore()
            if self.config.create_readme:
                self._create_readme()
            if self.config.create_requirements:
                self._create_requirements()
            
        except Exception as e:
            logger.error(f"Error generating skeleton: {e}")
            results["failed_operations"].append({
                "operation": "skeleton_generation",
                "error": str(e)
            })
        
        return results
    
    def _create_directory_recursive(self, spec: DirectorySpec) -> Dict[str, Any]:
        """Create directory and all subdirectories recursively"""
        result = {
            "created": [],
            "failed": [],
            "total": 0,
            "successful": 0
        }
        
        try:
            # Create the directory
            dir_path = os.path.join(self.config.project_root, spec.path)
            os.makedirs(dir_path, exist_ok=True)
            result["created"].append(spec.path)
            result["successful"] += 1
            result["total"] += 1
            
            # Create package files
            if self.config.language == "python":
                init_file = os.path.join(dir_path, "__init__.py")
                if not os.path.exists(init_file):
                    with open(init_file, 'w') as f:
                        f.write(f'# {spec.description}\n')
                    result["created"].append(f"{spec.path}/__init__.py")
                    result["successful"] += 1
                    result["total"] += 1
            elif self.config.language == "typescript":
                index_file = os.path.join(dir_path, "index.ts")
                if not os.path.exists(index_file):
                    with open(index_file, 'w') as f:
                        f.write(f'// {spec.description}\n')
                    result["created"].append(f"{spec.path}/index.ts")
                    result["successful"] += 1
                    result["total"] += 1
            
            # Create specified files in this directory
            for file_name in spec.files:
                file_path = os.path.join(dir_path, file_name)
                if not os.path.exists(file_path):
                    with open(file_path, 'w') as f:
                        f.write(f'# {file_name}\n# TODO: Implement\n')
                    result["created"].append(f"{spec.path}/{file_name}")
                    result["successful"] += 1
                    result["total"] += 1
            
            # Create subdirectories
            for sub_spec in spec.subdirectories:
                sub_result = self._create_directory_recursive(sub_spec)
                result["created"].extend(sub_result["created"])
                result["failed"].extend(sub_result["failed"])
                result["total"] += sub_result["total"]
                result["successful"] += sub_result["successful"]
                
        except Exception as e:
            logger.error(f"Error creating directory {spec.path}: {e}")
            result["failed"].append({
                "path": spec.path,
                "error": str(e)
            })
            result["total"] += 1
        
        return result
    
    def _create_file(self, spec: FileSpec) -> Dict[str, Any]:
        """Create a single file using SBH safety mechanisms"""
        try:
            # Use SBH applier for safe file creation
            rel_path = os.path.relpath(spec.path, self.config.project_root)
            result = apply_single_file(rel_path, spec.content, require_anchor=False)
            
            return {
                "success": True,
                "file": result.file,
                "sha256": result.sha256,
                "bytes_written": result.bytes_written
            }
            
        except Exception as e:
            logger.error(f"Error creating file {spec.path}: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    def _create_gitignore(self):
        """Create .gitignore file"""
        gitignore_content = self._get_gitignore_content()
        spec = FileSpec(
            path=".gitignore",
            content=gitignore_content,
            description="Git ignore file"
        )
        self._create_file(spec)
    
    def _create_readme(self):
        """Create README.md file"""
        readme_content = self._get_readme_content()
        spec = FileSpec(
            path="README.md",
            content=readme_content,
            description="Project README"
        )
        self._create_file(spec)
    
    def _create_requirements(self):
        """Create requirements file"""
        if self.config.language == "python":
            requirements_content = self._get_requirements_content()
            spec = FileSpec(
                path="requirements.txt",
                content=requirements_content,
                description="Python requirements"
            )
            self._create_file(spec)
        elif self.config.language == "typescript":
            package_json_content = self._get_package_json_content()
            spec = FileSpec(
                path="package.json",
                content=package_json_content,
                description="Node.js package configuration"
            )
            self._create_file(spec)
    
    def _get_gitignore_content(self) -> str:
        """Get gitignore content based on language"""
        if self.config.language == "python":
            return """# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# PyInstaller
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
.hypothesis/
.pytest_cache/

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db
"""
        elif self.config.language == "typescript":
            return """# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Coverage directory used by tools like istanbul
coverage/

# nyc test coverage
.nyc_output

# Grunt intermediate storage
.grunt

# Bower dependency directory
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons
build/Release

# Dependency directories
node_modules/
jspm_packages/

# TypeScript v1 declaration files
typings/

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db
"""
        else:
            return "# Add ignore patterns here\n"
    
    def _get_readme_content(self) -> str:
        """Get README content based on language"""
        if self.config.language == "python":
            return """# Project Name

A Python project generated by SBH (System Builder Hub).

## Setup

1. Install dependencies:
```bash
pip install -r requirements.txt
```

2. Run tests:
```bash
pytest
```

## Development

This project was generated from a structured plan using SBH's full build mode.

## License

MIT
"""
        elif self.config.language == "typescript":
            return """# Project Name

A TypeScript project generated by SBH (System Builder Hub).

## Setup

1. Install dependencies:
```bash
npm install
```

2. Run tests:
```bash
npm test
```

3. Build:
```bash
npm run build
```

## Development

This project was generated from a structured plan using SBH's full build mode.

## License

MIT
"""
        else:
            return """# Project Name

A project generated by SBH (System Builder Hub).

## Development

This project was generated from a structured plan using SBH's full build mode.

## License

MIT
"""
    
    def _get_requirements_content(self) -> str:
        """Get requirements.txt content"""
        return """# Core dependencies
flask>=2.0.0
flask-cors>=3.0.0

# Development dependencies
pytest>=6.0.0
pytest-cov>=2.0.0

# Add your project dependencies here
"""
    
    def _get_package_json_content(self) -> str:
        """Get package.json content"""
        return """{
  "name": "project-name",
  "version": "1.0.0",
  "description": "A TypeScript project generated by SBH",
  "main": "dist/index.js",
  "scripts": {
    "build": "tsc",
    "test": "jest",
    "dev": "ts-node src/index.ts",
    "start": "node dist/index.js"
  },
  "dependencies": {
    "express": "^4.18.0"
  },
  "devDependencies": {
    "@types/node": "^18.0.0",
    "@types/express": "^4.17.0",
    "typescript": "^4.9.0",
    "ts-node": "^10.9.0",
    "jest": "^29.0.0",
    "@types/jest": "^29.0.0"
  },
  "keywords": ["sbh", "generated"],
  "author": "SBH",
  "license": "MIT"
}"""
