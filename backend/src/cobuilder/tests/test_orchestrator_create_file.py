"""
Tests for orchestrator file creation functionality.
"""

import os
import tempfile
import unittest
from pathlib import Path
from unittest.mock import patch

from src.cobuilder.orchestrator import FullBuildOrchestrator, BuildStep, StepType, StepStatus
from src.cobuilder.persistent_registry import persistent_build_registry, BuildRecord


class TestOrchestratorCreateFile(unittest.TestCase):
    """Test orchestrator file creation functionality."""
    
    def setUp(self):
        """Set up test environment."""
        self.temp_dir = tempfile.mkdtemp()
        self.addCleanup(lambda: os.system(f"rm -rf {self.temp_dir}"))
        
        # Set up workspace environment
        self.workspace = os.path.join(self.temp_dir, "workspace")
        os.makedirs(self.workspace, exist_ok=True)
        
        self.orchestrator = FullBuildOrchestrator()
    
    def test_create_file_next_js_default(self):
        """Test that create_file_Next_js creates default Next.js page."""
        build_id = "test_build_nextjs_123"
        tenant_id = "test_tenant"
        
        # Create build record
        build_record = BuildRecord(
            build_id=build_id,
            tenant_id=tenant_id,
            idempotency_key="test_key",
            started_at="2025-01-01T00:00:00Z",
            status="running"
        )
        persistent_build_registry.register_build(build_record)
        
        # Create step
        step = BuildStep(
            step_id="create_file_Next_js",
            step_type=StepType.PATCH,
            description="Create Next.js page",
            patch_request="Create a Next.js page"
        )
        
        with patch.dict(os.environ, {'COB_WORKSPACE': self.workspace}):
            # Execute step
            success = self.orchestrator._execute_patch_step(step, tenant_id, build_id)
            
            # Verify success
            self.assertTrue(success, "File creation should succeed")
            self.assertEqual(step.status, StepStatus.COMPLETED)
            self.assertFalse(step.is_directory)
            self.assertIsNotNone(step.sha256)
            self.assertGreater(step.lines_changed, 0)
            
            # Verify file was created
            expected_path = f"{self.workspace}/{build_id}/apps/site/app/page.tsx"
            self.assertEqual(step.path, expected_path)
            self.assertTrue(os.path.exists(expected_path))
            self.assertTrue(os.path.isfile(expected_path))
            
            # Verify content
            with open(expected_path, 'r', encoding='utf-8') as f:
                content = f.read()
            self.assertIn("export default function Page()", content)
            self.assertIn("Hello, SBH", content)
            self.assertIn("Generated by Co-Builder", content)
            
            # Verify logs
            updated_record = persistent_build_registry.get_build(build_id, tenant_id)
            logs = list(updated_record.logs)
            file_logs = [log for log in logs if "[FILE] Writing:" in log or "[OK] Wrote file:" in log]
            self.assertGreater(len(file_logs), 0, "File creation logs should be recorded")
    
    def test_create_file_with_explicit_path_and_contents(self):
        """Test file creation with explicit path and contents."""
        build_id = "test_build_explicit_456"
        tenant_id = "test_tenant"
        
        # Create build record
        build_record = BuildRecord(
            build_id=build_id,
            tenant_id=tenant_id,
            idempotency_key="test_key",
            started_at="2025-01-01T00:00:00Z",
            status="running"
        )
        persistent_build_registry.register_build(build_record)
        
        # Create step with explicit path and content
        custom_path = f"{self.workspace}/{build_id}/custom/file.txt"
        custom_content = "Custom file content\nLine 2\nLine 3"
        
        step = BuildStep(
            step_id="create_file_custom",
            step_type=StepType.PATCH,
            description="Create custom file",
            patch_request={
                "path": custom_path,
                "content": custom_content
            }
        )
        
        with patch.dict(os.environ, {'COB_WORKSPACE': self.workspace}):
            # Execute step
            success = self.orchestrator._execute_patch_step(step, tenant_id, build_id)
            
            # Verify success
            self.assertTrue(success, "Custom file creation should succeed")
            self.assertEqual(step.path, custom_path)
            
            # Verify file was created with correct content
            self.assertTrue(os.path.exists(custom_path))
            with open(custom_path, 'r', encoding='utf-8') as f:
                actual_content = f.read()
            self.assertEqual(actual_content, custom_content)
            
            # Verify metadata
            self.assertEqual(step.lines_changed, 3)
            self.assertIsNotNone(step.sha256)
    
    def test_missing_path_after_dispatch(self):
        """Test that missing path after dispatch fails with clear error."""
        build_id = "test_build_missing_789"
        tenant_id = "test_tenant"
        
        # Create build record
        build_record = BuildRecord(
            build_id=build_id,
            tenant_id=tenant_id,
            idempotency_key="test_key",
            started_at="2025-01-01T00:00:00Z",
            status="running"
        )
        persistent_build_registry.register_build(build_record)
        
        # Create step that will fail to resolve path
        step = BuildStep(
            step_id="create_file_unknown",
            step_type=StepType.PATCH,
            description="Create unknown file type",
            patch_request="Create some file"  # No path/content provided
        )
        
        with patch.dict(os.environ, {'COB_WORKSPACE': self.workspace}):
            # Execute step
            success = self.orchestrator._execute_patch_step(step, tenant_id, build_id)
            
            # Should succeed (creates generic file)
            self.assertTrue(success, "Generic file creation should succeed")
            
            # Verify generic file was created
            expected_path = f"{self.workspace}/{build_id}/generated/create_file_unknown.txt"
            self.assertEqual(step.path, expected_path)
            self.assertTrue(os.path.exists(expected_path))
    
    def test_file_verification_passes(self):
        """Test that file verification works correctly."""
        build_id = "test_build_verify_999"
        tenant_id = "test_tenant"
        
        # Create build record
        build_record = BuildRecord(
            build_id=build_id,
            tenant_id=tenant_id,
            idempotency_key="test_key",
            started_at="2025-01-01T00:00:00Z",
            status="running"
        )
        persistent_build_registry.register_build(build_record)
        
        # Create a test file
        test_file = Path(self.workspace) / "test_file.txt"
        test_file.write_text("Test content\nLine 2")
        
        # Create step with file result
        step = BuildStep(
            step_id="create_file_test",
            step_type=StepType.PATCH,
            description="Test file creation"
        )
        step.result = {
            "file": str(test_file),
            "path": str(test_file),
            "lines_changed": 2,
            "sha256": "test_sha",
            "is_directory": False
        }
        
        # Test verification
        verification_result = self.orchestrator._run_post_step_verification(step, tenant_id, build_id)
        self.assertTrue(verification_result, "File verification should pass")
        
        # Check that logs were recorded
        updated_record = persistent_build_registry.get_build(build_id, tenant_id)
        logs = list(updated_record.logs)
        verification_logs = [log for log in logs if "Verifying artifact:" in log or "[OK] Verified file:" in log]
        self.assertGreater(len(verification_logs), 0, "Verification logs should be recorded")
    
    def test_file_verification_fails_for_missing_file(self):
        """Test that file verification fails when file doesn't exist."""
        build_id = "test_build_missing_file_111"
        tenant_id = "test_tenant"
        
        # Create build record
        build_record = BuildRecord(
            build_id=build_id,
            tenant_id=tenant_id,
            idempotency_key="test_key",
            started_at="2025-01-01T00:00:00Z",
            status="running"
        )
        persistent_build_registry.register_build(build_record)
        
        # Create step with non-existent file
        step = BuildStep(
            step_id="create_file_missing",
            step_type=StepType.PATCH,
            description="Test missing file"
        )
        step.result = {
            "file": "/nonexistent/file.txt",
            "path": "/nonexistent/file.txt",
            "lines_changed": 0,
            "sha256": "test_sha",
            "is_directory": False
        }
        
        # Test verification
        verification_result = self.orchestrator._run_post_step_verification(step, tenant_id, build_id)
        self.assertFalse(verification_result, "File verification should fail for missing file")
        
        # Check that error was logged
        updated_record = persistent_build_registry.get_build(build_id, tenant_id)
        logs = list(updated_record.logs)
        error_logs = [log for log in logs if "[ERROR]" in log and "Expected file not found" in log]
        self.assertGreater(len(error_logs), 0, "Error logs should be recorded")


if __name__ == '__main__':
    unittest.main()
