"""
Test that the full build API produces a bootable Next.js monorepo
"""

import os
import tempfile
import unittest
from unittest.mock import patch, MagicMock

from src.cobuilder.generators.pass1_orchestrator import generate_pass1_demo
from src.cobuilder.workspace_utils import verify_bootable_repo, get_workspace_path
from src.cobuilder.orchestrator import FullBuildOrchestrator
from src.cobuilder.plan_parser import PlanParser


class TestFullBuildProducesBootableRepo(unittest.TestCase):
    """Test that full build produces a bootable repository"""
    
    def setUp(self):
        """Set up test environment"""
        self.temp_dir = tempfile.mkdtemp()
        self.build_id = "test_build_bootable"
        self.workspace = self.temp_dir
        
        # Mock spec data
        self.spec = {
            "title": "AI Website Builder",
            "description": "Generated by Co-Builder",
            "sections": [
                {"type": "hero", "title": "Hero Section"},
                {"type": "feature-grid", "title": "Feature Grid Section"},
                {"type": "logo-cloud", "title": "Logo Cloud Section"},
                {"type": "showreel", "title": "Showreel Section"},
                {"type": "pricing", "title": "Pricing Section"},
                {"type": "cta-banner", "title": "CTA Banner Section"}
            ]
        }
    
    def tearDown(self):
        """Clean up test environment"""
        import shutil
        if os.path.exists(self.temp_dir):
            shutil.rmtree(self.temp_dir)
    
    def test_pass1_orchestrator_produces_bootable_repo(self):
        """Test that Pass-1 orchestrator produces a bootable repository"""
        # Run the Pass-1 orchestrator
        result = generate_pass1_demo(self.build_id, self.workspace, self.spec)
        
        # Assert success
        self.assertTrue(result["success"], f"Pass-1 generation failed: {result.get('error', 'Unknown error')}")
        self.assertTrue(result["bootable"], "Generated repo should be bootable")
        
        # Verify workspace path
        workspace_path = get_workspace_path(self.build_id)
        self.assertEqual(result["workspace_path"], workspace_path)
        
        # Verify key files exist
        key_paths = result["key_paths"]
        self.assertTrue(os.path.exists(key_paths["root_package_json"]))
        self.assertTrue(os.path.exists(key_paths["site_package_json"]))
        self.assertTrue(os.path.exists(key_paths["prisma_schema"]))
        self.assertTrue(os.path.exists(key_paths["main_page"]))
        self.assertTrue(os.path.exists(key_paths["lead_api"]))
        self.assertTrue(os.path.exists(key_paths["checkout_api"]))
        
        # Verify verification results
        verification = result["verification"]
        self.assertTrue(verification["is_bootable"])
        self.assertEqual(len(verification["missing_files"]), 0)
        self.assertEqual(len(verification["missing_dirs"]), 0)
        self.assertEqual(len(verification["missing_sections"]), 0)
        self.assertTrue(verification["has_main_page"])
        self.assertTrue(verification["has_lead_api"])
        self.assertTrue(verification["has_checkout_api"])
    
    def test_verification_gate_catches_missing_files(self):
        """Test that verification gate catches missing files"""
        # Create a partial workspace (missing key files)
        workspace_path = get_workspace_path(self.build_id)
        os.makedirs(workspace_path, exist_ok=True)
        
        # Create only some files
        os.makedirs(os.path.join(workspace_path, "apps", "site"), exist_ok=True)
        with open(os.path.join(workspace_path, "package.json"), "w") as f:
            f.write('{"name": "test"}')
        
        # Run verification
        verification = verify_bootable_repo(self.build_id)
        
        # Should not be bootable
        self.assertFalse(verification["is_bootable"])
        self.assertGreater(len(verification["missing_files"]), 0)
        self.assertIn("pnpm-workspace.yaml", verification["missing_files"])
        self.assertIn("apps/site/package.json", verification["missing_files"])
    
    def test_verification_gate_catches_missing_sections(self):
        """Test that verification gate catches missing section components"""
        # Create a workspace with most files but missing sections
        workspace_path = get_workspace_path(self.build_id)
        os.makedirs(workspace_path, exist_ok=True)
        
        # Create required files
        with open(os.path.join(workspace_path, "package.json"), "w") as f:
            f.write('{"name": "test"}')
        with open(os.path.join(workspace_path, "pnpm-workspace.yaml"), "w") as f:
            f.write('packages:\n  - "apps/*"\n  - "packages/*"')
        
        # Create site package
        os.makedirs(os.path.join(workspace_path, "apps", "site"), exist_ok=True)
        with open(os.path.join(workspace_path, "apps", "site", "package.json"), "w") as f:
            f.write('{"name": "@app/site"}')
        
        # Create Prisma schema
        os.makedirs(os.path.join(workspace_path, "prisma"), exist_ok=True)
        with open(os.path.join(workspace_path, "prisma", "schema.prisma"), "w") as f:
            f.write('model Lead { id Int @id }')
        
        # Create main page
        os.makedirs(os.path.join(workspace_path, "apps", "site", "app"), exist_ok=True)
        with open(os.path.join(workspace_path, "apps", "site", "app", "page.tsx"), "w") as f:
            f.write('export default function Page() { return <div>Hello</div> }')
        
        # Create API routes
        os.makedirs(os.path.join(workspace_path, "apps", "site", "app", "api", "lead"), exist_ok=True)
        with open(os.path.join(workspace_path, "apps", "site", "app", "api", "lead", "route.ts"), "w") as f:
            f.write('export async function POST() { return Response.json({ok: true}) }')
        
        os.makedirs(os.path.join(workspace_path, "apps", "site", "app", "api", "checkout"), exist_ok=True)
        with open(os.path.join(workspace_path, "apps", "site", "app", "api", "checkout", "route.ts"), "w") as f:
            f.write('export async function POST() { return Response.json({ok: true}) }')
        
        # Run verification
        verification = verify_bootable_repo(self.build_id)
        
        # Should not be bootable due to missing sections
        self.assertFalse(verification["is_bootable"])
        self.assertGreater(len(verification["missing_sections"]), 0)
    
    @patch('src.cobuilder.generators.pass1_orchestrator.generate_repo_scaffold')
    def test_pass1_orchestrator_handles_generator_failure(self, mock_scaffold):
        """Test that Pass-1 orchestrator handles generator failures gracefully"""
        # Mock scaffold generator to fail
        mock_scaffold.return_value = {
            "success": False,
            "error": "Scaffold generation failed"
        }
        
        # Run the Pass-1 orchestrator
        result = generate_pass1_demo(self.build_id, self.workspace, self.spec)
        
        # Should fail gracefully
        self.assertFalse(result["success"])
        self.assertEqual(result["step"], "repo_scaffold")
        self.assertIn("Scaffold generation failed", result["error"])
    
    def test_workspace_path_helpers(self):
        """Test workspace path helper functions"""
        # Test get_workspace_path
        workspace_path = get_workspace_path(self.build_id)
        expected_path = os.path.join(self.temp_dir, self.build_id)
        self.assertEqual(workspace_path, expected_path)
        
        # Test that path doesn't exist yet
        self.assertFalse(os.path.exists(workspace_path))


if __name__ == '__main__':
    unittest.main()
