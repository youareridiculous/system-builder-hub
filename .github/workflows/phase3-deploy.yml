name: Phase 3 ARM64 Build and Deploy

on:
  workflow_dispatch:
  push:
    branches: [ main ]

env:
  AWS_REGION: ${{ vars.AWS_REGION }}
  AWS_ACCOUNT_ID: ${{ vars.AWS_ACCOUNT_ID }}
  ECR_REPOSITORY: ${{ vars.ECR_REPO }}
  ECS_CLUSTER: ${{ vars.ECS_CLUSTER }}
  ECS_SERVICE: ${{ vars.ECS_SERVICE }}
  TASK_DEFINITION_FAMILY: sbh-task-dev
  APP_URL: ${{ vars.APP_URL }}
  S3_BUCKET_NAME: ${{ vars.S3_BUCKET_NAME }}
  AWS_ROLE_ARN: ${{ vars.AWS_ROLE_ARN }}

permissions:
  id-token: write      # required for OIDC assume-role
  contents: read       # read source
  packages: write      # if using GHCR or actions that need write

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ vars.AWS_ROLE_ARN }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Build, test, and push Docker image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
        TIMESTAMP: ${{ github.run_number }}
      run: |
        echo "üöÄ Starting Phase-3 ARM64 build with guardrails..."
        
        cd backend
        
        # Guardrail 1: Check build context size and forbidden paths
        echo "üìä Checking build context size and forbidden paths..."
        CONTEXT_SIZE=$(du -sh . | cut -f1)
        CONTEXT_SIZE_BYTES=$(du -sb . | cut -f1)
        CONTEXT_FILES=$(find . -type f | wc -l)
        
        echo "Build context: $CONTEXT_SIZE ($CONTEXT_SIZE_BYTES bytes, $CONTEXT_FILES files)"
        
        # Check for forbidden paths that should never be in build context
        FORBIDDEN_PATHS=(".venv" "node_modules" "__pycache__" ".pytest_cache" ".mypy_cache")
        for path in "${FORBIDDEN_PATHS[@]}"; do
          if find . -name "$path" -type d | grep -q .; then
            echo "‚ùå Forbidden path found in build context: $path"
            echo "üí° Check .dockerignore and exclude $path"
            find . -name "$path" -type d
            exit 1
          fi
        done
        
        # Fail if context is too large (> 50MB or > 5,000 files for backend-only)
        MAX_SIZE_BYTES=52428800   # 50MB (reduced for backend-only)
        MAX_FILES=5000
        
        if [ "$CONTEXT_SIZE_BYTES" -gt "$MAX_SIZE_BYTES" ]; then
          echo "‚ùå Build context too large: $CONTEXT_SIZE_BYTES bytes (max: $MAX_SIZE_BYTES)"
          echo "üí° Check .dockerignore and exclude unnecessary files"
          echo "üìÅ Largest directories:"
          du -sh * | sort -hr | head -10
          exit 1
        fi
        
        if [ "$CONTEXT_FILES" -gt "$MAX_FILES" ]; then
          echo "‚ùå Too many files in context: $CONTEXT_FILES (max: $MAX_FILES)"
          echo "üí° Check .dockerignore and exclude unnecessary files"
          exit 1
        fi
        
        echo "‚úÖ Build context size check passed"
        echo "‚úÖ No forbidden paths (.venv, node_modules, __pycache__) found"
        
        # Build Docker image for ARM64
        echo "üî® Building Docker image for ARM64..."
        docker buildx build \
          --platform linux/arm64 \
          -t $ECR_REGISTRY/$ECR_REPOSITORY:phase3-$TIMESTAMP \
          -t $ECR_REGISTRY/$ECR_REPOSITORY:latest \
          --push \
          .
        
        # Verify pushed image
        echo "üîç Verifying pushed image..."
        IMAGE_DIGEST=$(docker inspect $ECR_REGISTRY/$ECR_REPOSITORY:phase3-$TIMESTAMP --format '{{index .RepoDigests 0}}' | cut -d'@' -f2)
        IMAGE_FULL_URI="$ECR_REGISTRY/$ECR_REPOSITORY@$IMAGE_DIGEST"
        
        echo "Verifying image: $IMAGE_FULL_URI"
        
        # Check manifest for ARM64
        MANIFEST=$(aws ecr batch-get-image --repository-name $ECR_REPOSITORY --image-ids imageTag=phase3-$TIMESTAMP --query 'images[0].imageManifest' --output text)
        if ! echo "$MANIFEST" | grep -q "ARM64"; then
          echo "‚ùå Image manifest does not contain ARM64 descriptor."
          exit 1
        fi
        
        # Check image size
        ACTUAL_IMAGE_SIZE_BYTES=$(aws ecr describe-images --repository-name $ECR_REPOSITORY --image-ids imageTag=phase3-$TIMESTAMP --query 'imageDetails[0].imageSizeInBytes' --output text)
        ACTUAL_IMAGE_SIZE_MB=$(echo "scale=2; $ACTUAL_IMAGE_SIZE_BYTES / (1024 * 1024)" | bc)
        
        echo "Actual image size: $ACTUAL_IMAGE_SIZE_MB MB"
        
        MIN_IMAGE_SIZE_MB=50
        if (( $(echo "$ACTUAL_IMAGE_SIZE_MB < $MIN_IMAGE_SIZE_MB" | bc -l) )); then
          echo "‚ùå Image size ($ACTUAL_IMAGE_SIZE_MB MB) is below minimum expected ($MIN_IMAGE_SIZE_MB MB)."
          exit 1
        fi
        
        echo "‚úÖ Image verification passed: ARM64 platform, $ACTUAL_IMAGE_SIZE_MB MB"
        
        # Update ECS task definition
        echo "üìù Updating ECS task definition..."
        CURRENT_TD=$(aws ecs describe-task-definition --task-definition $TASK_DEFINITION_FAMILY --query 'taskDefinition')
        NEW_TD=$(echo "$CURRENT_TD" | jq --arg image "$ECR_REGISTRY/$ECR_REPOSITORY:phase3-$TIMESTAMP" '.containerDefinitions[0].image = $image')
        CLEAN_TD=$(echo "$NEW_TD" | jq 'del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)')
        echo "$CLEAN_TD" > new_task_def.json
        NEW_REVISION=$(aws ecs register-task-definition --cli-input-json file://new_task_def.json --query 'taskDefinition.revision' --output text)
        echo "New task definition revision: $NEW_REVISION"
        
        # Deploy to ECS
        echo "üöÄ Deploying to ECS..."
        aws ecs update-service --cluster $ECS_CLUSTER --service $ECS_SERVICE --task-definition $TASK_DEFINITION_FAMILY:$NEW_REVISION
        
        # Wait for deployment to stabilize
        echo "‚è≥ Waiting for deployment to stabilize..."
        aws ecs wait services-stable --cluster $ECS_CLUSTER --services $ECS_SERVICE
        
        echo "‚úÖ Deployment completed successfully"
        
        # Check health endpoint
        echo "üè• Checking health endpoint..."
        for i in {1..30}; do
          HEALTH=$(curl -s $APP_URL/api/health | jq -r '.ok // false');
          if [ "$HEALTH" = "true" ]; then
            echo "‚úÖ Health check passed";
            break;
          fi;
          echo "Attempt $i: Health check failed, retrying in 10 seconds...";
          sleep 10;
        done
        
        if [ "$HEALTH" != "true" ]; then echo "‚ùå Health check failed after 30 attempts"; exit 1; fi
        
        # Apply database schema
        echo "üóÑÔ∏è Applying database schema..."
        MIGRATION_RESULT=$(curl -s -X POST $APP_URL/api/migrate/up || echo "endpoint_not_found")
        if [ "$MIGRATION_RESULT" = "endpoint_not_found" ]; then
          echo "Migration endpoint not found, trying schema fix endpoint...";
          SCHEMA_RESULT=$(curl -s -X POST $APP_URL/api/fix-db-schema || echo "endpoint_not_found");
          if [ "$SCHEMA_RESULT" = "endpoint_not_found" ]; then
            echo "‚ùå No migration endpoints available";
            exit 1;
          else
            echo "‚úÖ Schema fix endpoint called successfully";
          fi;
        else
          echo "‚úÖ Migration endpoint called successfully";
        fi
        
        # Verify Phase-3 functionality
        echo "üß™ Verifying Phase-3 functionality..."
        CONV_RESPONSE=$(curl -s -X POST $APP_URL/api/memory/conversations -H "Content-Type: application/json" -H "X-User-Email: test@example.com" -H "X-Tenant: demo" -d '{"title": "Test Conversation"}' || echo "failed")
        if [ "$CONV_RESPONSE" = "failed" ]; then echo "‚ùå Conversation creation failed"; exit 1; fi
        CONV_ID=$(echo "$CONV_RESPONSE" | jq -r '.id // empty')
        if [ -z "$CONV_ID" ]; then echo "‚ùå No conversation ID returned"; exit 1; fi
        echo "‚úÖ Conversation created with ID: $CONV_ID"
        
        MSG_RESPONSE=$(curl -s -X POST $APP_URL/api/memory/conversations/$CONV_ID/messages -H "Content-Type: application/json" -H "X-User-Email: test@example.com" -H "X-Tenant: demo" -d '{"role": "user", "content": {"text": "Hello, world!"}}' || echo "failed")
        if [ "$MSG_RESPONSE" = "failed" ]; then echo "‚ùå Message creation failed"; exit 1; fi
        echo "‚úÖ Message created successfully"
        
        SPEC_RESPONSE=$(curl -s -X POST $APP_URL/api/specs -H "Content-Type: application/json" -H "X-User-Email: test@example.com" -H "X-Tenant: demo" -d '{"title": "Test Spec", "plan_manifest": {"type": "website"}, "repo_skeleton": {"files": []}}' || echo "failed")
        if [ "$SPEC_RESPONSE" = "failed" ]; then echo "‚ùå Spec creation failed"; exit 1; fi
        SPEC_ID=$(echo "$SPEC_RESPONSE" | jq -r '.id // empty')
        if [ -z "$SPEC_ID" ]; then echo "‚ùå No spec ID returned"; exit 1; fi
        echo "‚úÖ Spec created with ID: $SPEC_ID"
        
        BUILD_RESPONSE=$(curl -s -X POST $APP_URL/api/builds -H "Content-Type: application/json" -H "X-User-Email: test@example.com" -H "X-Tenant: demo" -d "{\"spec_id\": \"$SPEC_ID\"}" || echo "failed")
        if [ "$BUILD_RESPONSE" = "failed" ]; then echo "‚ùå Build creation failed"; exit 1; fi
        BUILD_ID=$(echo "$BUILD_RESPONSE" | jq -r '.build_id // empty')
        if [ -z "$BUILD_ID" ]; then echo "‚ùå No build ID returned"; exit 1; fi
        echo "‚úÖ Build created with ID: $BUILD_ID"
        
        # Test S3 functionality
        echo "ü™£ Testing S3 functionality..."
        S3_TEST_RESPONSE=$(curl -s -X POST $APP_URL/api/builds/$BUILD_ID/artifacts -H "Content-Type: application/json" -H "X-User-Email: test@example.com" -H "X-Tenant: demo" -d '{"test": "s3_write"}' || echo "failed")
        if [ "$S3_TEST_RESPONSE" = "failed" ]; then echo "‚ùå S3 test failed"; exit 1; fi
        echo "‚úÖ S3 functionality verified"
        
        # Final health check
        echo "üè• Final health check..."
        HEALTH_RESPONSE=$(curl -s $APP_URL/api/health)
        echo "$HEALTH_RESPONSE" | jq .
        DB_STATUS=$(echo "$HEALTH_RESPONSE" | jq -r '.database.status')
        PM_STATUS=$(echo "$HEALTH_RESPONSE" | jq -r '.persistent_memory.status')
        STORAGE_STATUS=$(echo "$HEALTH_RESPONSE" | jq -r '.storage.status')
        if [ "$DB_STATUS" != "healthy" ] || [ "$PM_STATUS" != "healthy" ] || [ "$STORAGE_STATUS" != "healthy" ]; then
          echo "‚ùå Not all subsystems are healthy:";
          echo "  Database: $DB_STATUS";
          echo "  Persistent Memory: $PM_STATUS";
          echo "  Storage: $STORAGE_STATUS";
          exit 1;
        fi
        echo "‚úÖ All subsystems are healthy!"
        
        echo "üéâ Phase 3 deployment completed successfully!"
        echo "üìä Summary:"
        echo "  Image: $ECR_REGISTRY/$ECR_REPOSITORY:phase3-$TIMESTAMP"
        echo "  Image Digest: $IMAGE_DIGEST"
        echo "  Task Definition Revision: $NEW_REVISION"
        echo "  Context Size: $CONTEXT_SIZE ($CONTEXT_FILES files)"
        echo "  Image Size: $ACTUAL_IMAGE_SIZE_MB MB"
        echo "  Platform: linux/arm64"
        echo "  Conversation ID: $CONV_ID"
        echo "  Spec ID: $SPEC_ID"
        echo "  Build ID: $BUILD_ID"